\chapter{Discussion and conclusions}
This chapter evaluates the result and the methods used to reach the results of this thesis.
\section{Result}
Four different tests were run to evaluate the performance of the in this thesis implemented text rendering solution. The four tests were developed with the goal to evaluate if the implementation solved all the problems set up in the problem formulation. The problems formulation described in chapter one follows.
\begin{itemize}
  \item How can distance fields be used when rendering text and how does the technique work?
  \item What distance field size is it necessary to use for the rendered text to get equally good appearance as the text rendered from Visiarcs current text rendering implementation?
  \item Is it possible to generate a distance field fast enough for the user not to be able to determine if the distance field was pre generated or not?
\end{itemize} 
The first problem of the problem formulation is answered by chapter two of this report. Therefore this problem was not covered by the tests in the result chapter. The two visual evaluation tests were developed to give an answer to the second problem of the problem formulation. The visual evaluation tests only evaluated the distance field sizes 64x64 and 128x128. The reason for only evaluating two distance field sizes was that other distance field size gave too bad results. Smaller distance field sizes resulted in too rounded corners of the glyphs and bigger distance field sizes did not improve the quality enough to be prefered over the distance field size 128x128.

There are many sources of error in the visual evaluations. One of the possible errors is that the in this thesis developed text rendering solution uses a different type of anti aliasing than the old implementation. This might be the reason for some of the errors in the visual evaluations. Another possible error in the visual evaluations is that the distance fields rendered by the distance field generating module implemented in this thesis generates smaller distance fields than the textures generated by the old text rendering implementation. A drawback of this is that the renderings of the old text rendering solution and in this thesis implemented text rendering solution might have different sub-pixel positioning of glyphs due to rounding. This can be seen in the results of visual evaluation \#1 presented in appendix A where some glyphs have more errors on for example vertical lines or horizontal lines depending on vertical and horizontal sub-pixel positioning.

The test performance evaluation was developed to give an answer to the third problem formulation. The test consisted of measuring the execution time of the function for generating distance fields implemented in this thesis on three different mobile devices. The three devices used in the test were very different to eachother. The computational power of the CPUs and the GPUs differ between all the devices aswell as the release year. The performance of the devices in the test was reflected on the age of the devices which is natural considering they get better and better for every year. 

The result of the test distance tolerance evaluation showed that the distance field generation time increased for small values on the constant distance\_tolerance. The test was only run on one mobile device which was a Samsung S6. There is a small possibility that the result of this test differ between mobile devices because of different hardware. This is not covered by the test. The test shows that a value of the constant distance\_tolerance higher than 0.2 for distance field size 128x128 gives about the same distance field generation time. The fact that 0.2 gives about the same distance field generation time as higher values gives no reason to use a higher value than 0.2.

\begin{figure}[H]
\includegraphics[scale=0.55]{lorem_perfect}
\caption{The word "Lorem" rendered by the implementation done in this thesis with distance field size 128x128 and $distance\_tolerance=0.01$.}
\label{fig:isLine}
\end{figure}

The value of the constant distance\_tolerance used for beziér to line segment approximations was $0.1$ in all the runs of the performance evaluation. This value is pretty low and gives almost no visual artifacts between the line segments of the outline of the glyphs. A higher value of this constant would decrease the distance field generation time for all the glyphs containing beziér curves. The result of this test can therefore be seen as the maximum generation time for the devices in many cases.

As the visual evaluation shows bigger distance fields result in less errors when rendering the glyph. The test visual evaluation \#2 resulted in an average of 2.81\% and 1.04\% using 64x64 respectively 128x128 distance fields. Comparing the average numbers of the test gives that rendering with a 64x64 distance fields result in almost 3 times more errors than rendering with an 128x128 distance fields. This is an expected result considering an 128x128 distance fields use 4 times the memory of a 64x64 distance field. Because memory usage is important on mobile device this is a strong argument for the 64x64 distance fields. When choosing distance field size the factors that matters are visual appearance, memory consumption and distance field generation speed. Because mobile devices usually have small screens and text rendered on a mobile device usually do not cover the whole screen with one glyph the distance field size 64x64 is recommended for usage.

The device performing the worst of the three devices in the performance test was the Samsung galaxy tab 1. The average distance field generation time of this device in the performance test was 0.0069 s for the 64x64 distance field and 0.0159 s for the 128x128 distance fields. One of the requirements set up by VisiArc on the performance of this thesis was that the implementation should be able to generate a distance field between two frames. Assuming the mobile devices renders at 60 FPS the maximum distance field generation time is $\frac{1}{60}=0.01666\dots$. Because the average generation time for all devices in the performance test are lower than $\frac{1}{60}$, this requirement is fulfilled and the user should not be able to notice any difference between typing in a character that has a distance field pre generated and a character that does not. There is always possible to find arguments against this. One way to find arguments against the performance of the distance field generation module is to find bad cases. One bad case for the distance field rendering module would be if the app wants to render the whole alphabet in a font with no pre rendered distance fields. This could happen for example when scrolling through a pdf file that contains a line with a different font than the rest of the file listing the whole alphabet. Using 128x128 distance field size and a Samsung galaxy tab 1 this would freeze the app for a couple of seconds if the distance field generation is not done in a separate thread.

As mentioned in this section the recommended values for the constant distance\_tolerance and the distance field size are $0.2$ and 64x64. Figure \ref{fig:recommendation} shows how a rendering with the recommended values can look like.

\begin{figure}[H]
\includegraphics[scale=0.55]{lorem}
\caption{The word "Lorem" rendered by the implementation done in this thesis with the in this thesis recommended distance field size and distance\_tolerance.}
\label{fig:recommendation}
\end{figure}


\section{Method}
When generating distance fields in real time there is no time to iterate through all pixels. Example of such algorithms are described by \citet{meijster} and \citet{Danielsson}. Optimizations and approximations has to be done to be able to skip some of the pixels. The method used for generating the distance fields in this thesis is not very well known. The only two similar implementations used as reference for the method are as mentioned in the method chapter the implementation in GLyphy and Qt. The fact that Qt has a similar method to the one used in this thesis implemented in their products proves that the method works and is used in the industry. 

The fact that the method used for generating distance fields in this thesis uses two steps of approximations makes it not exact. The first approximation done is the beziér to line segment approximation. This approximation depends on the constant distance\_tolerance. The approximations gets better the lower the value of the constant distance\_tolerance is but it will never become exact. Because decreasing the value of the constant distance\_tolerance increases the distance field generation time it is not desirable to use an infinite low distance\_tolerance. The second approximation done is the gradient drawing. The distances in the gradients are not real distances. The distances are scaled so that the range [0, 255] covers the whole gradient in the increasing direction. The fact that the distance field might not contain the real distances to the shape makes it lose usability in some applications where real distances are important. Luckily this is not the case when rendering distance field text because the boundary of the shape will still be interpolated to the correct position.